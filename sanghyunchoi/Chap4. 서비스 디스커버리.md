## 4장: 서비스 디스커버리
### 목차
- 4.1 서비스 위치 찾기
- 4.2 클라우드에서 서비스 디스커버리
- 4.3 스프링 유레카 서비스 구축
- 4.4 스프링 유레카에 서비스 등록
- 4.5 서비스 디스커버리를 사용한 서비스 검색
- 4.6 요약
   
   
### 들어가기 전
- 분산 아키텍처에서는 시스템의 물리적 위치 주소를 찾아야 한다. 이를 공식적으로 서비스 디스커버리라고 한다.
- 서비스 디스커버리는 다음 두 가지 핵심적인 이유로 매우 중요하다.
  1. App 팀은 서비스 디스커버리를 사용해 해당 환경에서 실행하는 서비스 인스턴스 개수를 신속 확장 / 축소 가능
     - 모놀리식과 싱글 테넌트(한명의 고객) 애플리케이션에 익숙해져 수직 확장만이 유일한 확장이라는 생각에서 벗어나 더 많은 서버를 추가해 수평 확장하는 사고로 전환시켜준다.
     - 일반적으로 모놀리식 방식 사용 시 필요 용량보다 초과 구매하게 된다.
     - MSA 방식 사용 시 새로운 인스턴스만 확장, 축소 가능 → 서비스 소비자와 별개로 진행하여 추상화에 도움이 된다.
  2. 애플리케이션 회복성을 향상하는 데 도움이 된다.
     - MSA 인스턴스가 비정상이거나 가용하지 않을 시 서비스 디스커버리 엔진은 가용 서비스 목록에서 인스턴스 제거
     
     
### 4.1 서비스 위치 찾기
- 여러 서버로 분산된 자원 호출할 때 마다 해당 물리적 위치를 찾아야 한다.
  - 클라우드가 아닌 환경은 대게 DNS와 네트워크 로드 밸런서로 해결한다.
    - 서비스 소비자의 요청을 받으면 로드밸런서는 사용자 액세스 경로를 기반으로 라우팅 테이블에서 물리적 주소를 찾는다.
      - 라우팅 테이블 항목: 해당 서비스를 호스팅하는 서버가 1개 이상 포함된 서버 목록이 있다. 로드밸런서는 목록 중 하나를 선택해 요청을 전달한다.
    - 서비스의 각 인스턴스는 여러 서버에 배포, App의 서버 개수는 정적이며 영구적인 경우가 많다.
    - 보조 로드 밸런서가 유휴 상태로 대기하고 주 로드 밸런서가 핑으로 정상인지 확인, 정상 아닐 시 보조 밸런서 활성화되고 주 로드 밸런서의 IP 주소를 인수해 요청 처리
    - 사방이 벽으로 쌓인 회사 데이터 센터 안에서 실행되는 App과 정적 서버 그룹에서 실행되는 소수 서비스에서 잘 동작! 클라우드 기반의 마이크로서비스 App에서는 그렇지 못하다.
  - DNS와 네트워크 로드 밸런서가 MSA에 적합하지 않은 이유
    1. 단일 장애 지점
       - 로드 밸런서 다운 시 의존하는 모든 App 다운된다.
       - 로드 밸런서 고가용하게 만들더라도 App 인프라 안에서 집중화된 병목 지점이 될 가능성 높다.
    2. 수평 확장의 제약성
       - 로드 밸런서는 클러스터에 서비스를 모아 연결하므로 부하 분산 인프라를 여러 서버에 수평적으로 확장 하는 것이 제한된다.
    3. 정적 관리
       - 전통적 로드 밸런서는 대부분 서비스를 신속히 등록하고 취소하도록 설계되지 않는다.
    4. 복잡성
       - 로드 밸런서가 서비스에 대한 프록시 역할을 하므로 서비스 소비자에게 요청 시 물리적 서비스에 매핑된 요청 정보가 있어야 한다. 매핑 규칙을 수동으로 정의하고 배포해야 하므로 복잡성 가중
    - 대부분의 App이 중앙 집중화된 네트워크 인프라를 이용해 처리될 수 있는 크기와 규모가 있는 기업 환경에서 잘 작동, SSL 종료를 한 곳에서 처리하고 서비스의 포트 보안을 관리하는 면에서 중요 역할을 함. 하지만 클라우드 환경에서 효율적으로 확장되지 않고 비용 효율도 낮아 결국 제대로 동작하지 못한다.
     
### 4.2 클라우드에서 서비스 디스커버리
- 클라우드 기반 MSA  서비스 디스커버리 메커니즘
  1. 고가용성
     - 한 노드가 사용할 수 없게 되면 클러스터의 다른 노드가 인계를 받을 수 있어야 한다.
  2. 피어 투 피어
     - 서비스 디스커버리 클러스터의 각 노드는 서비스 인스턴스의 상태를 공유한다.
  3. 부하 분산
     - 서비스 디스커버리는 요청을 동적으로 부하 분산해서 서비스 디스커버리가 관리하는 모든 서비스 인스턴스에 분배해야 한다.
  4. 회복성
     - 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐시해야 한다.
       - 로컬 캐싱은 서비스 디스커버리를 점진적 저하 시킬 수 있다. 
       - 서비스 디스커버리가 가용하지 않을 때 로컬 캐시에 저장된 정보를 기반으로 서비스를 찾고 동작하게 한다.
  5. 장애 내성
     - 서비스 인스턴스의 비정상을 탐지하고 가용 서비스 목록에서 인스턴스를 제거해야 한다.
     
### 4.2.1 서비스 디스커버리 아키텍처
- 네 가지 개념을 이해해야 한다.
  1. 서비스 등록
     - 서비스를 서비스 디스커버리 에이전트에 어떻게 등록하는가?
  2. 클라이언트가 서비스 주소 검색
     - 서비스 클라이언트가 어떻게 서비스 정보를 검색하는가?
  3. 정보 공유
     - 서비스 정보를 노드 간에 어떻게 공유하는가?
  4. 상태 모니터링
     - 서비스가 자신의 상태 정보를 서비스 디스커버리 에이전트에 어떻게 전달하는가?
- 서비스 인스턴스 시작 → 서비스 디스커버리 인스턴스는 자신의 물리적 위치와 경로, 포트를 등록 
- 서비스의 각 인스턴스는 고유 IP 주소가 있지만, 동일한 서비스 ID 등록
  - 서비스 ID는 서비스 인스턴스 그룹을 고유하게 식별하는 키
- 서비스는 일반적으로 1개의 서비스 디스커버리 인스턴스에 등록
- 서비스 디스커버리 구현체 대부분은 P2P모델을 사용해 데이터를 클러스터에 있는 다른 노드에 전파
- 각 서비스 인스턴스는 자기 상태를 서비스 디스커버리 서비스에 푸시하거나 서비스 디스커버리 서비스가 인스턴스 상태를 추출한다.
- 클라이언트 측 부하 분산 방법
  - 소비 행위자가 서비스를 호출해야 할 때 다음과 같이 한다.
    1. 서비스 디스커버리 서비스에 접속 후 데이터를 서비스 소비자 기기에 로컬 캐시한다.
    2. 서비스 소비자는 캐시에서 위치 정보를 검색한다.
    3. 클라이언트는 주기적으로 서비스 디스커버리 서비스에 접속해 서비스 인스턴스 캐시를 새로고침한다.
    
    
### 4.3 스프링 유레카 서비스 구축
1. pom.xml 유레카 디펜던시 추가 (서버)
2. .yml 또는 .properties 파일에서 유레카 서비스를 독립 실행 모드로 설정하기 위한 세팅 추가
   - 유레카 서비스 등록 여부
   - 레지스트리 정보 로컬 캐싱 여부
   - 서버가 요청을 받기 전 대기할 초기 시간 
     - 기본적으로 유레카는 모든 서비스가 등록할 기회를 갖도록 5분을 기다린 후 등록된 서비스 정보 공유
3. 부트 스트랩 클래스에 애너테이션 추가 @EnableEurekaServer

### 4.4 스프링 유레카에 서비스 등록
1. pom.xml 유레카 디펜던시 추가 (클라이언트)
   - 스프링 클라우드가 유레카 서비스와 상호 작용하는 데 필요한 jar 파일 포함
2. .yml 또는 .properties 파일에서 코드 추가
   - 유레카에 등록할 서비스의 논리 이름
     - 애플리 케이션 ID를 의미, 서비스 인스턴스의 그룹을 의미
   - 서비스 이름 대신 서비스 IP 주소 등록
   - 유레카에 서비스 등록  여부
   - 유레카 서비스 위치 여부
     - true → 검색할 때 마다 유레카 서비스 호출 대신 레지스트리 로컬로 캐시된다.
   - 레지스트리 사본을 로컬로 가져오기 위한 URL
     - 클라이언트가 위치를 확인하는 데 사용할 유레카 서비스 목록을 쉼표로 구분해 보관
3. 엔드 포인트 + 논리 이름 호출 시 레지스트리에 있는 조직 서비스를 볼 수 있다.
